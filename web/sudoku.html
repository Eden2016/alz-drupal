<!--
Sudoku Generator
v0.2

Copyright (c) 2010, David J. Rager
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Fourth Woods Media nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This is a simple user interface for interacting with the Sudoku puzzle
generator. The interface provides game display and user input. It shows the
current game state and any error conditions if conflicting values are entered.
When the game is completed a dialog will be displayed showing the length of time
it took to solve the puzzle.
-->
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="X-UA-Compatible" content="IE=Edge">
		<title>Sudoku</title>
<style>
@media print
{
	.sudokuTop, .sudokuBottom
	{
		display:none;
	}
	.sudokuContainer
	{
		width:600px;
		height:450px;
	}
	.inner
	{
		width:100% !important;
		height:100% !important;
	}
	.inner td.hint
	{
		color:black !important;
		font-weight:bold;
	}
}
.sudokuContainer
{
	position:relative;
}
table
{
	border-spacing:0;
	border-collapse:collapse;
}
td
{
	border: 1px #00276e solid;
	padding:0;
}

.inner td
{
	width:50px;
	height:50px;
	text-align:center;
	font-size:30px;
	cursor:default;
	background-color:#fff;
	border-color:#888;
	color:#00276e;
}

.inner td:hover
{
	background-color:#eee;
}

.erase .inner td:hover
{
	background-color:#e27000;
	color:white;
}

.number .inner td:hover
{
	background-color:#00276e;
	color:white;
}

.inner tr > td.error
{
	color:#ff0000 !important;
}

.inner td.hint
{
	background-color:#ddd !important;
	color:#00276e;
}
.inner tr > td.hint:hover
{
	color:#00276e;
}

.inner td.selected
{
	background-color:#aaa !important;
}

.inner td.selected.found
{
	background-color:#67B367 !important;
}

.sudokuTop
{
	padding-bottom: 10px;
	border:none;
}
.sudokuBottom
{
	width:100%;
	border:none;
	background-color:#00276e;
	color:white;
	border:1px solid #00276e;
}
.sudokuBottom tr td
{
	border:1px solid #00276e;
	width:50px;
	height:50px;
	font-size:2em;
	cursor:default;
	text-align:center;
	padding:0px;
	margin:0px;
	cursor:pointer;
}
.sudokuBottom tr td:hover
{
	background-color:#5c72aa;
	border:border:1px solid #5c72aa;
}
.highlight
{
	background-color:#e6ebf6;
	color:#00276e;
	border:border:1px solid #e6ebf6;
}
.sudokuTop > div > .highlight
{
	color:#e27000;
	background-color:white;
	border:none;
}
#overlayBackground
{
	position: absolute;
	z-index:50;
	height: 90%;
	width: 100%;
	left: 0;
	right: 0;
	top: 0;
	bottom: 0;
	background-color:black;
	opacity:0;
	margin-top:60px;
}
#overlayIcons
{
	position: absolute;
	z-index:50;
	height: 14%;
	width: 100%;
	left: 0;
	right: 0;
	top: 0;
	bottom: 0;
	background-color:black;
	opacity:0;
}
#settings, #gameEnded
{
	position: absolute;
	z-index:100;
	height: auto;
	width: 100%;
	left: 0;
	right: 0;
	top: 0;
	bottom: 0;
	margin: 25% auto;
	text-align:center;
}
.controls
{
	width:50%;
	margin:0 auto;
}
#new, #solveIt, #resetCells, #continue
{
	width: 100%;
	margin: 5px;
	font-size: 20px;
	font-weight: bold;
	background-color:#00276e;
	color:#fff;
}
#settings label, #enableErrors
{
	font-size: 20px;
	font-weight: bold;
	width:100%;
	display:block;
	margin:5px;
	border: 2px outset buttonface;
	color:black;
	background-color:#f6f8fc;
}
.selectedLabel
{
	font-weight: bolder;
	background-color:#00276e !important;
	color:#fff !important;
}
.hide
{
	display:none;
}
.icon
{
	font-size:40px !important;
}

.menuItem
{
	display:inline-block;
	margin-left:20px;
	cursor:pointer;
	color:#00276e;
	font-weight:bold;
	font-size:25px;
	width:65px;
	text-align:center;
}

.loadingScreen
{
	position: absolute;
	width: 50%;
	height: 120px;
	left: 0;
	top: 0;
	bottom: 0;
	right: 0;
	overflow: hidden;
	margin: auto;
	z-index:100;
}
.disable
{
	color:red;
}
.loadingScreen i
{
	font-size: 125px;
	text-align: center;
	margin:auto;
	display:block;
	color:#00276e;
}
.found
{
	background-color:#B3DFB3 !important;
}
#availableHints
{
	position: absolute;
	background-color: #e27000;
	border-radius: 51px;
	width: 21px;
	margin-left: 10px;
	font-size: 19px;
}
.inner td.choosenHint
{
	background-color: #E0B081 !important;
}
.orange
{
	color:#e27000;
}
</style>

<link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script>/*!
 * jQuery-runner - v2.3.3 - 2014-08-06
 * https://github.com/jylauril/jquery-runner/
 * Copyright (c) 2014 Jyrki Laurila <https://github.com/jylauril>
 */
(function(){var a,b,c,d,e,f,g,h,i;if(c={version:"2.3.3",name:"jQuery-runner"},g=this.jQuery||this.Zepto||this.$,!g||!g.fn)throw new Error("["+c.name+"] jQuery or jQuery-like library is required for this plugin to work");e={},d=function(a){return(10>a?"0":"")+a},i=1,f=function(){return"runner"+i++},h=function(a,b){return a["r"+b]||a["webkitR"+b]||a["mozR"+b]||a["msR"+b]||function(a){return setTimeout(a,30)}}(this,"equestAnimationFrame"),b=function(a,b){var c,e,f,g,h,i,j,k,l,m,n;for(b=b||{},k=[36e5,6e4,1e3,10],i=["",":",":","."],h="",g="",f=b.milliseconds,e=k.length,l=0,0>a&&(a=Math.abs(a),h="-"),c=m=0,n=k.length;n>m;c=++m)j=k[c],l=0,a>=j&&(l=Math.floor(a/j),a-=l*j),(l||c>1||g)&&(c!==e-1||f)&&(g+=(g?i[c]:"")+d(l));return h+g},a=function(){function a(b,c,d){var h;return this instanceof a?(this.items=b,h=this.id=f(),this.settings=g.extend({},this.settings,c),e[h]=this,b.each(function(a,b){g(b).data("runner",h)}),this.value(this.settings.startAt),void((d||this.settings.autostart)&&this.start())):new a(b,c,d)}return a.prototype.running=!1,a.prototype.updating=!1,a.prototype.finished=!1,a.prototype.interval=null,a.prototype.total=0,a.prototype.lastTime=0,a.prototype.startTime=0,a.prototype.lastLap=0,a.prototype.lapTime=0,a.prototype.settings={autostart:!1,countdown:!1,stopAt:null,startAt:0,milliseconds:!0,format:null},a.prototype.value=function(a){this.items.each(function(b){return function(c,d){var e;c=g(d),e=c.is("input")?"val":"text",c[e](b.format(a))}}(this))},a.prototype.format=function(a){var c;return c=this.settings.format,(c=g.isFunction(c)?c:b)(a,this.settings)},a.prototype.update=function(){var a,b,c,d,e;this.updating||(this.updating=!0,c=this.settings,e=g.now(),d=c.stopAt,a=c.countdown,b=e-this.lastTime,this.lastTime=e,a?this.total-=b:this.total+=b,null!==d&&(a&&this.total<=d||!a&&this.total>=d)&&(this.total=d,this.finished=!0,this.stop(),this.fire("runnerFinish")),this.value(this.total),this.updating=!1)},a.prototype.fire=function(a){this.items.trigger(a,this.info())},a.prototype.start=function(){var a;this.running||(this.running=!0,(!this.startTime||this.finished)&&this.reset(),this.lastTime=g.now(),a=function(b){return function(){b.running&&(b.update(),h(a))}}(this),h(a),this.fire("runnerStart"))},a.prototype.stop=function(){this.running&&(this.running=!1,this.update(),this.fire("runnerStop"))},a.prototype.toggle=function(){this.running?this.stop():this.start()},a.prototype.lap=function(){var a,b;return b=this.lastTime,a=b-this.lapTime,this.settings.countdown&&(a=-a),(this.running||a)&&(this.lastLap=a,this.lapTime=b),b=this.format(this.lastLap),this.fire("runnerLap"),b},a.prototype.reset=function(a){var b;a&&this.stop(),b=g.now(),"number"!=typeof this.settings.startAt||this.settings.countdown||(b-=this.settings.startAt),this.startTime=this.lapTime=this.lastTime=b,this.total=this.settings.startAt,this.value(this.total),this.finished=!1,this.fire("runnerReset")},a.prototype.info=function(){var a;return a=this.lastLap||0,{running:this.running,finished:this.finished,time:this.total,formattedTime:this.format(this.total),startTime:this.startTime,lapTime:a,formattedLapTime:this.format(a),settings:this.settings}},a}(),g.fn.runner=function(b,d,f){var h,i;switch(b||(b="init"),"object"==typeof b&&(f=d,d=b,b="init"),h=this.data("runner"),i=h?e[h]:!1,b){case"init":new a(this,d,f);break;case"info":if(i)return i.info();break;case"reset":i&&i.reset(d);break;case"lap":if(i)return i.lap();break;case"start":case"stop":case"toggle":if(i)return i[b]();break;case"version":return c.version;default:g.error("["+c.name+"] Method "+b+" does not exist")}return this},g.fn.runner.format=b}).call(this);
</script>

<script type="text/javascript">
/*
* Sudoku Generator
* v0.2
*
* Copyright (c) 2010, David J. Rager
* All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met: 
* 
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Fourth Woods Media nor the names of its
*       contributors may be used to endorse or promote products derived from
*       this software without specific prior written permission.
* 
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* This is a sudoku puzzle generator and solver. This program provides two
* generation algorithms, a solver and methods to update and check the state of
* the puzzle. This program does not provide any user interface controls.
*
* To create a new puzzle just instantiate the Sudoku object:
*
* var thePuzzle = new Sudoku();
*
* The puzzle is represented as a 9x9 matrix of numbers 0-9. A cell value of zero
* indicates a cell that has been masked from view for the user to discover. A
* user interface should display all the non-zero values to the user and blank
* cells for any cell containing a zero.
*
* The puzzle uses either a simple shuffle algorithm or the backtracking solver
* (the default) to create the puzzle.
*
* To start a new game call:
*
* thePuzzle.newGame();
*
* This class includes a solver that will solve the sudoku using a backtracking
* algorithm. To solve the puzzle call the solve() method:
*
* thePuzzle.solve();
*
* If there is more than one solution to the sudoku puzzle, the solver will show
* only one of them at random. The solver does not know if there is more than one
* solution.
*
* The enumSolutions() method is a modified version of the solver that will count
* all possible solutions for 
*
* Have fun. Send any comments, bugs, contribs to rageratwork@gmail.com
*/

// The Array class doesn't have a contains() method. We create one to make the
// code cleaner and more readable.
// Note, it seems that the decreasing while loop is the fastest way to iterate
// over a collection in javascript:
// http://blogs.sun.com/greimer/entry/best_way_to_code_a
//
// This method takes one parameter:
// 	obj - the object to search for in the array. the object must be of the
// 	      same type as the objects stored in the array.
Array.prototype.contains = function(obj) {
	var i = this.length;
	while (i--) {
		if (this[i] === obj) {
			return true;
		}
	}
	return false;
}

// This clear method resets the values in the array to zero.
Array.prototype.clear = function() {
	var i = this.length;
	while (i--) {
		this[i] = 0;
	}
}

// The timeDiff object is used for debugging, calculating the execution time for
// the board generation algorithm. It may in the future be used to measure the
// time it takes for the user to solve the puzzle.
var timeDiff  =  {
	// this method marks the beginning of an event.
	start:function (){
		d = new Date();
		time  = d.getTime();
	},

	// this method returns the time elapsed in milliseconds since the
	// beginning of an event.
	end:function (){
		d = new Date();
		return (d.getTime()-time);
	}
}

// The Sudoku class stores the matrix array and implements the game logic.
// Instantiation of this class will automatically generate a new puzzle.
function Sudoku() {
	// 'private' methods...

	// stores the 9x9 game data. the puzzle data is stored with revealed
	// numbers as 1-9 and hidden numbers for the user to discover as zeros.
	this.matrix = new Array(81);

	// initial puzzle is all zeros.
	this.matrix.clear();

	// stores the difficulty level of the puzzle 0 is easiest.
	this.level = 0;

	// this method initializes the sudoku puzzle beginning with a root
	// solution and randomly shuffling rows, columns and values. the result
	// of this method will be a completely solved sudoku board. the shuffle
	// is similar to that used by the sudoku puzzle at:
	//
	// http://www.dhtmlgoodies.com/scripts/game_sudoku/game_sudoku.html
	//
	// this method takes one parameter:
	// 	matrix - the 9x9 array to store the puzzle data. the array
	// 		 contents will be overwritten by this method.
	this.shuffle = function(matrix) {
		// create the root sudoku solution. this produces the following
		// sudoku:
		//
		// 1 2 3 | 4 5 6 | 7 8 9
		// 4 5 6 | 7 8 9 | 1 2 3
		// 7 8 9 | 1 2 3 | 4 5 6
		// ---------------------
		// 2 3 4 | 5 6 7 | 8 9 1
		// 5 6 7 | 8 9 1 | 2 3 4
		// 8 9 1 | 2 3 4 | 5 6 7
		// ---------------------
		// 3 4 5 | 6 7 8 | 9 1 2
		// 6 7 8 | 9 1 2 | 3 4 5
		// 9 1 2 | 3 4 5 | 6 7 8
		for (var i = 0; i < 9; i++)
			for (var j = 0; j < 9; j++)
				matrix[i * 9 + j] = (i*3 + Math.floor(i/3) + j) % 9 + 1;

		// randomly shuffle the numbers in the root sudoku. pick two
		// numbers n1 and n2 at random. scan the board and for each
		// occurence of n1, replace it with n2 and vice-versa. repeat
		// several times. we pick 42 to make Douglas Adams happy.
		for(var i = 0; i < 42; i++) {
			var n1 = Math.ceil(Math.random() * 9);
			var n2;
			do {
				n2 = Math.ceil(Math.random() * 9);
			}
			while(n1 == n2);

			for(var row = 0; row < 9; row++) {
				for(var col = 0; col < col; k++) {
					if(matrix[row * 9 + col] == n1)
						matrix[row * 9 + col] = n2;
					else if(matrix[row * 9 + col] == n2)
						matrix[row * 9 + col] = n1;
				}
			}
		}

		// randomly swap corresponding columns from each column of
		// subsquares
		//
		//   |       |       |
		//   |       |       |
		//   V       V       V
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		//----------------------
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		//----------------------
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		//
		// note that we cannot swap corresponding rows from each row of
		// subsquares.
		for (var c = 0; c < 42; c++) {
			var s1 = Math.floor(Math.random() * 3);
			var s2 = Math.floor(Math.random() * 3);

			for(var row = 0; row < 9; row++) {
				var tmp = this.matrix[row * 9 + (s1 * 3 + c % 3)];
				this.matrix[row * 9 + (s1 * 3 + c % 3)] = this.matrix[row * 9 + (s2 * 3 + c % 3)];
				this.matrix[row * 9 + (s2 * 3 + c % 3)] = tmp;
			}
		}

		// randomly swap columns within each column of subsquares
		//
		//         | | |
		//         | | |
		//         V V V
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		//----------------------
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		//----------------------
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		for (var s = 0; s < 42; s++) {
			var c1 = Math.floor(Math.random() * 3);
			var c2 = Math.floor(Math.random() * 3);

			for(var row = 0; row < 9; row++) {
				var tmp = this.matrix[row * 9 + (s % 3 * 3 + c1)];
				this.matrix[row * 9 + (s % 3 * 3 + c1)] = this.matrix[row * 9 + (s % 3 * 3 + c2)];
				this.matrix[row * 9 + (s % 3 * 3 + c2)] = tmp;
			}
		}

		// randomly swap rows within each row of subsquares
		//
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		//----------------------
		// . . . | . . . | . . . <---
		// . . . | . . . | . . . <---
		// . . . | . . . | . . . <---
		//----------------------
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		// . . . | . . . | . . .
		for (var s = 0; s < 42; s++) {
			var r1 = Math.floor(Math.random() * 3);
			var r2 = Math.floor(Math.random() * 3);

			for(var col = 0; col < 9; col++)
			{
				var tmp = this.matrix[(s % 3 * 3 + r1) * 9 + col];
				this.matrix[(s % 3 * 3 + r1) * 9 + col] = this.matrix[(s % 3 * 3 + r2) * 9 + col];
				this.matrix[(s % 3 * 3 + r2) * 9 + col] = tmp;
			}
		}

		// we could also randomly swap rows and columns of subsquares
		//
		//   |       |       |
		//   |       |       |
		// /---\   /---\   /---\
		// . . . | . . . | . . .  \
		// . . . | . . . | . . .  | <---
		// . . . | . . . | . . .  /
		//----------------------
		// . . . | . . . | . . .  \
		// . . . | . . . | . . .  | <---
		// . . . | . . . | . . .  /
		//----------------------
		// . . . | . . . | . . .  \
		// . . . | . . . | . . .  | <---
		// . . . | . . . | . . .  /
		//
		// we could also rotate the board 90, 180 or 270 degrees and
		// mirror left to right and/or top to bottom.
	}

	// this method randomly masks values in a solved sudoku board. for the
	// easiest level it will hide 5 cells from each 3x3 subsquare.
	//
	// this method makes no attempt to ensure a unique solution and simply
	// (naively) just masks random values. usually there will be only one
	// solution however, there may be two or more. i've seen boards with as
	// many as 6 or 7 solutions using this function, though that is pretty
	// rare.
	//
	// this method takes two parameters:
	// 	matrix - the game array completely initialized with the game
	// 		 data.
	// 	mask - an array to store the 9x9 mask data. the mask array will
	// 	       contain the board that will be presented to the user.
	this.maskBoardEasy = function(matrix, mask) {
		var i, j, k;
		for(i = 0; i < 81; i++)
			mask[i] = matrix[i];

		for (var i = 0; i < 3; i++) {
			for (var j = 0; j < 3; j++) {
				// for each 3x3 subsquare, pick 5 random cells
				// and mask them.
				for (var k = 0; k < 5; k++) {
					var c;
					do {
						c = Math.floor(Math.random() * 9);
					}
					while(mask[(i * 3 + Math.floor(c / 3)) * 9 + j * 3 + c % 3] == 0);

					mask[(i * 3 + Math.floor(c / 3)) * 9 + j * 3 + c % 3] = 0;
				}
			}
		}
	}

	// this method scans all three zones that contains the specified cell
	// and populates an array with values that have not already been used in
	// one of the zones. the order of the values in the array are randomized
	// so the solver may simply iterate linearly through the array to try
	// the values in a random order rather than sequentially.
	//
	// this method takes three parameters:
	// 	matrix - the array containing the current state of the puzzle.
	// 	cell - the cell for which to retrieve available values.
	// 	avail - the array to receive the available values. if this
	// 		parameter is null, this method simply counts the number
	// 		of available values without returning them.
	//
	// this method returns the length of the data in the available array.
	this.getAvailable = function(matrix, cell, avail)
	{
		var i, j, row, col, r, c;
		var arr = new Array(9);
		arr.clear();

		row = Math.floor(cell / 9);
		col = cell % 9;

		// row
		for(i = 0; i < 9; i++)
		{
			j = row * 9 + i;
			if(matrix[j] > 0)
				arr[matrix[j] - 1] = 1;
		}

		// col
		for(i = 0; i < 9; i++)
		{
			j = i * 9 + col;
			if(matrix[j] > 0)
			{
				arr[matrix[j] - 1] = 1;
			}
		}

		// square
		r = row - row % 3;
		c = col - col % 3;
		for(i = r; i < r + 3; i++)
			for(j = c; j < c + 3; j++)
				if(matrix[i * 9 + j] > 0)
					arr[matrix[i * 9 + j] - 1] = 1;

		j = 0;
		if(avail != null)
		{
			for(i = 0; i < 9; i++)
				if(arr[i] == 0)
					avail[j++] = i + 1;
		}
		else
		{
			for(i = 0; i < 9; i++)
				if(arr[i] == 0)
					j++;
			return j;
		}

		if(j == 0)
			return 0;

		for(i = 0; i < 18; i++)
		{
			r = Math.floor(Math.random() * j);
			c = Math.floor(Math.random() * j);
			row = avail[r];
			avail[r] = avail[c];
			avail[c] = row;
		}

		return j;
	}

	// this method is used by the solver to find the next cell to be filled.
	// the cell is chosen by finding a cell with the least amount of
	// available values to try.
	//
	// this method takes one parameter:
	// 	matrix - the array containing the current state of the puzzle.
	//
	// this method returns the next cell, or -1 if there are no cells left
	// to choose.
	this.getCell = function(matrix)
	{
		var cell = -1, n = 10, i, j;
		var avail = new Array(9);
		avail.clear();

		for(i = 0; i < 81; i++)
		{
			if(matrix[i] == 0)
			{
				j = this.getAvailable(matrix, i, null);

				if(j < n)
				{
					n = j;
					cell = i;
				}

				if (n == 1)
					break;
			}
		}

		return cell;
	}

	// this is the actual solver. it implements a backtracking algorithm in
	// which it randomly selects numbers to try in each cell. it starts
	// with the first cell and picks a random number. if the number works in
	// the cell, it recursively chooses the next cell and starts again. if
	// all the numbers for a cell have been tried and none work, a number
	// chosen for a previous cell cannot be part of the solution so we have
	// to back up to the last cell and choose another number. if all the
	// numbers for that cell have also been tried, we back up again. this
	// continues until a value is chosen for all 81 cells.
	//
	// this method takes one parameter:
	// 	matrix - the array containing the current state of the puzzle.
	//
	// this method returns 1 if a solution has been found or 0 if there was
	// not a solution.
	this.solve = function(matrix)
	{
		var i, j, ret = 0;
		var cell = this.getCell(matrix);

		// since this is the solver that is following the sudoku rules,
		// if getCell returns -1 we are guaranteed to have found a valid
		// solution. in this case we just return 1 (for 1 solution, see
		// enumSolutions for more information).
		if(cell == -1)
			return 1;

		var avail = new Array(9);
		avail.clear();

		j = this.getAvailable(matrix, cell, avail);
		for(i = 0; i < j; i++)
		{
			matrix[cell] = avail[i];

			// if we found a solution, return 1 to the caller.
			if(this.solve(matrix) == 1)
				return 1;

			// if we haven't found a solution yet, try the next
			// value in the available array.
		}

		// we've tried all the values in the available array without
		// finding a solution. reset the cell value back to zero and
		// return zero to the caller.
		matrix[cell] = 0;
		return 0;
	}

	// this method counts the number of possible solutions for a given
	// puzzle. this uses the same algorithm as the solver but tries all
	// the available values for all the cells incrementing a count every
	// time a new solution is found. this method is used by the mask
	// function to ensure there is only one solution to the puzzle.
	//
	// this method performs well for a puzzle with 20 or so hints. do not
	// try this function on a blank puzzle (zero hints). there is not enough
	// time remaining in the physical universe to enumerate all the possible
	// sudoku boards. when this method returns, the puzzle passed in is
	// restored to its original state.
	//
	// this method takes one parameter:
	// 	matrix - the array containing the current state of the puzzle.
	//
	// this method returns the number of solutions found or 0 if there was
	// not a solution.
	this.enumSolutions = function(matrix)
	{
		var i, j, ret = 0;
		var cell = this.getCell(matrix);

		// if getCell returns -1 the board is completely filled which
		// means we found a solution. return 1 for this solution.
		if(cell == -1)
			return 1;

		var avail = new Array(9);
		avail.clear();

		j = this.getAvailable(matrix, cell, avail);
		for(i = 0; i < j; i++)
		{
			// we try each available value in the array and count
			// how many solutions are produced.
			matrix[cell] = avail[i];

			ret += this.enumSolutions(matrix);

			// for the purposes of the mask function, if we found
			// more than one solution, we can quit searching now
			// so the mask algorithm can try a different value.
			if(ret > 1)
				break;
		}

		matrix[cell] = 0;
		return ret;
	}

	// this method generates a minimal sudoku puzzle. minimal means that no
	// remaining hints on the board may be removed and still generate a
	// unique solution. when this method returns the resulting puzzle will
	// contain about 20 to 25 hints that describe a puzzle with only one
	// solution.
	//
	// this method takes two parameters:
	// 	matrix - the game array completely initialized with the game
	// 		 data.
	// 	mask - an array to store the 9x9 mask data. the mask array will
	// 	       contain the board that will be presented to the user.
	this.maskBoard = function(matrix, mask)
	{
		var i, j, k, r, c, n = 0, a, hints = 0, cell, val;
		var avail = new Array(9);
		avail.clear();

		var tried = new Array(81);
		tried.clear();

		// start with a cleared out board
		mask.clear();

		// randomly add values from the solved board to the masked
		// board, picking only cells that cannot be deduced by existing
		// values in the masked board.
		//
		// the following rules are used to determine the cells to
		// populate:
		// 1. based on the three zones to which the cell belongs, if
		// more than one value can go in the cell (i.e. the selected
		// cell value and at least one other value), check rule two.
		// 2. for each zone, if the selected value could go in another
		// free cell in the zone then the cell may be selected as a
		// hint. this rule must be satisfied by all three zones.
		//
		// both rules must pass for a cell to be selected. once all 81
		// cells have been checked, the masked board will represent a
		// puzzle with a single solution.
		do
		{
			// choose a cell at random.
			do
			{
				cell = Math.floor(Math.random() * 81);
			}
			while((mask[cell] != 0) || (tried[cell] != 0));
			val = matrix[cell];

			// see how many values can go in the cell.
			i = this.getAvailable(mask, cell, null);

			if(i > 1)
			{
				// two or more values can go in the cell based
				// on values used in each zone.
				//
				// check each zone and make sure the selected
				// value can also be used in at least one other
				// cell in the zone.
				var cnt, row = Math.floor(cell / 9), col = cell % 9;

				cnt = 0; // count the cells in which the value
					 // may be used.

				// look at each cell in the same row as the
				// selected cell.
				for(i = 0; i < 9; i++)
				{	
					// don't bother looking at the selected
					// cell. we already know the value will
					// work.
					if(i == col)
						continue;

					j = row * 9 + i; // j stores the cell index

					// if the value is already filled, skip
					// to the next.
					if(mask[j] > 0)
						continue;

					// get the values that can be used in
					// the cell.
					a = this.getAvailable(mask, j, avail);

					// see if our value is in the available
					// value list.
					for(j = 0; j < a; j++)
					{
						if(avail[j] == val)
						{
							cnt++;
							break;
						}
						avail[j] = 0;
					}
				}

				// if the count is greater than zero, the
				// selected value could also be used in another
				// cell in that zone. we repeat the process with
				// the other two zones.
				if(cnt > 0)
				{
					// col
					cnt = 0;
					for(i = 0; i < 9; i++)
					{
						if(i == row)
							continue;

						j = i * 9 + col;
						if(mask[j] > 0)
							continue;
						a = this.getAvailable(mask, j, avail);
						for(j = 0; j < a; j++)
						{
							if(avail[j] == val)
							{
								cnt++;
								break;
							}
							avail[j] = 0;
						}
					}

					// if the count is greater than zero,
					// the selected value could also be used
					// in another cell in that zone. we
					// repeat the process with the last
					// zone.
					if(cnt > 0)
					{
						// square
						cnt = 0;
						r = row - row % 3;
						c = col - col % 3;
						for(i = r; i < r + 3; i++)
						{
							for(j = c; j < c + 3; j++)
							{
								if((i == row) && (j == col))
									continue;
	
								k = i * 9 + j;
								if(mask[k] > 0)
									continue;
								a = this.getAvailable(mask, k, avail);
								for(k = 0; k < a; k++)
								{
									if(avail[k] == val)
									{
										cnt++;
										break;
									}
									avail[k] = 0;
								}
							}
						}

						if(cnt > 0)
						{
							mask[cell] = val;
							hints++;
						}
					}
				}
			}

			tried[cell] = 1;
			n++;
		}
		while(n < 81);

		// at this point we should have a masked board with about 40 to
		// 50 hints. randomly select hints and remove them. for each
		// removed hint, see if there is still a single solution. if so,
		// select another hint and repeat. if not, replace the hint and
		// try another.
		do
		{
			do
			{
				cell = Math.floor(Math.random() * 81);
			}
			while((mask[cell] == 0) || (tried[cell] == 0));

			val = mask[cell];

			var t = this;
			var solutions = 0;

			mask[cell] = 0;
			solutions = this.enumSolutions(mask);

			if(solutions > 1)
				mask[cell] = val;

			tried[cell] = 0;
			hints--;
		}
		while(hints > 0);

		// at this point we have a board with about 20 to 25 hints and a
		// single solution.
	}


	// this method checks whether a value will work in a given cell. it
	// checks each zone to ensure the value is not already used.
	//
	// this method takes three parameters:
	// 	row - the row of the cell
	// 	col - the column of the cell
	// 	val - the value to try in the cell
	//
	// this method returns true if the value can be used in the cell, false
	// otherwise.
	this._checkVal = function(matrix, row, col, val) {
		var i, j, r, c;
		// check each cell in the row to see if the value already
		// exists in the row. do not look at the value of the cell in
		// the column we are trying. repeat for each zone.
		for(i = 0; i < 9; i++)
		{
			if((i != col) && (matrix[row * 9 + i] == val))
				return false;
		}

		// check col
		for(i = 0; i < 9; i++)
		{
			if((i != row) && (matrix[i * 9 + col] == val))
				return false;
		}

		// check square
		r = row - row % 3;
		c = col - col % 3;
		for(i = r; i < r + 3; i++)
			for(j = c; j < c + 3; j++)
				if(((i != row) || (j != col)) && (matrix[i * 9 + j] == val))
					return false;

		return true;
	}

	// 'public' methods

	// this method checks whether a value will work in a given cell. it
	// checks each zone to ensure the value is not already used.
	//
	// this method takes three parameters:
	// 	row - the row of the cell
	// 	col - the column of the cell
	// 	val - the value to try in the cell
	//
	// this method returns true if the value can be used in the cell, false
	// otherwise.
	this.checkVal = function(row, col, val)
	{
		return this._checkVal(this.matrix, row, col, val);
	}

	// this method sets the value for a particular cell. this is called by
	// the user interface when the user enters a value.
	//
	// this method takes three parameters:
	// 	row - the row of the cell
	// 	col - the column of the cell
	// 	val - the value to enter in the cell
	this.setVal = function(row, col, val)
	{
		this.matrix[row * 9 + col] = val;
	}

	// this method gets the value for a particular cell. this is called by
	// the user interface for displaying the contents of a cell.
	//
	// this method takes two parameters:
	// 	row - the row of the cell
	// 	col - the column of the cell
	//
	// this method returns the value of the cell at the specified location.
	this.getVal = function(row, col)
	{
		return this.matrix[row * 9 + col];
	}

	// this method initializes a new game using the solver to generate the
	// board.
	this._newGame = function() {
		var i, hints = 0;
		var mask = new Array(81);

		// clear out the game matrix.
		this.matrix.clear();

		// call the solver on a completely empty matrix. this will
		// generate random values for cells resulting in a solved board.
		this.solve(this.matrix);

		// generate hints for the solved board. if the level is easy,
		// use the easy mask function.
		if(this.level == 0)
		{
			this.maskBoardEasy(this.matrix, mask);
		}
		else
		{
			// the level is medium or greater. use the advanced mask
			// function to generate a minimal sudoku puzzle with a
			// single solution.
			this.maskBoard(this.matrix, mask);

			// if the level is medium, randomly add 4 extra hints.
			if(this.level == 1)
			{
				for(i = 0; i < 4; i++)
				{
					do
					{
						var cell = Math.floor(Math.random() * 81);
					}
					while(mask[cell] != 0);

					mask[cell] = this.matrix[cell];
				}
			}
		}

		// save the solved matrix.
		this.save = this.matrix;

		// set the masked matrix as the puzzle.
		this.matrix = mask;

		timeDiff.start();
	}

	this.done;

	this._doHints = function(matrix, mask, tried, hints)
	{
		// at this point we should have a masked board with about 40 to
		// 50 hints. randomly select hints and remove them. for each
		// removed hint, see if there is still a single solution. if so,
		// select another hint and repeat. if not, replace the hint and
		// try another.
		if(hints > 0)
		{
			do
			{
				cell = Math.floor(Math.random() * 81);
			}
			while((mask[cell] == 0) || (tried[cell] == 0));

			val = mask[cell];

			var t = this;
			var solutions = 0;

			mask[cell] = 0;
			solutions = this.enumSolutions(mask);
			//console.log("timeout");

			if(solutions > 1)
				mask[cell] = val;

			tried[cell] = 0;
			hints--;
			var t = this;
			setTimeout(function(){t._doHints(matrix, mask, tried, hints);}, 50);
		}
		else
		{
			this.save = this.matrix;
			this.matrix = mask;
			this.done();
		}

		//console.log(hints);

		// at this point we have a board with about 20 to 25 hints and a
		// single solution.
	}

	this._doMask = function(matrix, mask)
	{
		var i, j, k, r, c, n = 0, a, hints = 0, cell, val;
		var avail = new Array(9);
		avail.clear();

		var tried = new Array(81);
		tried.clear();

		// start with a cleared out board
		mask.clear();

		// randomly add values from the solved board to the masked
		// board, picking only cells that cannot be deduced by existing
		// values in the masked board.
		//
		// the following rules are used to determine the cells to
		// populate:
		// 1. based on the three zones to which the cell belongs, if
		// more than one value can go in the cell (i.e. the selected
		// cell value and at least one other value), check rule two.
		// 2. for each zone, if the selected value could go in another
		// free cell in the zone then the cell may be selected as a
		// hint. this rule must be satisfied by all three zones.
		//
		// both rules must pass for a cell to be selected. once all 81
		// cells have been checked, the masked board will represent a
		// puzzle with a single solution.
		do
		{
			// choose a cell at random.
			do
			{
				cell = Math.floor(Math.random() * 81);
			}
			while((mask[cell] != 0) || (tried[cell] != 0));
			val = matrix[cell];

			// see how many values can go in the cell.
			i = this.getAvailable(mask, cell, null);

			if(i > 1)
			{
				// two or more values can go in the cell based
				// on values used in each zone.
				//
				// check each zone and make sure the selected
				// value can also be used in at least one other
				// cell in the zone.
				var cnt, row = Math.floor(cell / 9), col = cell % 9;

				cnt = 0; // count the cells in which the value
					 // may be used.

				// look at each cell in the same row as the
				// selected cell.
				for(i = 0; i < 9; i++)
				{	
					// don't bother looking at the selected
					// cell. we already know the value will
					// work.
					if(i == col)
						continue;

					j = row * 9 + i; // j stores the cell index

					// if the value is already filled, skip
					// to the next.
					if(mask[j] > 0)
						continue;

					// get the values that can be used in
					// the cell.
					a = this.getAvailable(mask, j, avail);

					// see if our value is in the available
					// value list.
					for(j = 0; j < a; j++)
					{
						if(avail[j] == val)
						{
							cnt++;
							break;
						}
						avail[j] = 0;
					}
				}

				// if the count is greater than zero, the
				// selected value could also be used in another
				// cell in that zone. we repeat the process with
				// the other two zones.
				if(cnt > 0)
				{
					// col
					cnt = 0;
					for(i = 0; i < 9; i++)
					{
						if(i == row)
							continue;

						j = i * 9 + col;
						if(mask[j] > 0)
							continue;
						a = this.getAvailable(mask, j, avail);
						for(j = 0; j < a; j++)
						{
							if(avail[j] == val)
							{
								cnt++;
								break;
							}
							avail[j] = 0;
						}
					}

					// if the count is greater than zero,
					// the selected value could also be used
					// in another cell in that zone. we
					// repeat the process with the last
					// zone.
					if(cnt > 0)
					{
						// square
						cnt = 0;
						r = row - row % 3;
						c = col - col % 3;
						for(i = r; i < r + 3; i++)
						{
							for(j = c; j < c + 3; j++)
							{
								if((i == row) && (j == col))
									continue;
	
								k = i * 9 + j;
								if(mask[k] > 0)
									continue;
								a = this.getAvailable(mask, k, avail);
								for(k = 0; k < a; k++)
								{
									if(avail[k] == val)
									{
										cnt++;
										break;
									}
									avail[k] = 0;
								}
							}
						}

						if(cnt > 0)
						{
							mask[cell] = val;
							hints++;
						}
					}
				}
			}

			tried[cell] = 1;
			n++;
		}
		while(n < 81);

		var t = this;
		setTimeout(function(){t._doHints(matrix, mask, tried, hints);}, 50);
	}

	this.newGame = function() {
		var i, hints = 0;
		var mask = new Array(81);

		// clear out the game matrix.
		this.matrix.clear();

		// call the solver on a completely empty matrix. this will
		// generate random values for cells resulting in a solved board.
		this.solve(this.matrix);

		// generate hints for the solved board. if the level is easy,
		// use the easy mask function.
		if(this.level == 0)
		{
			this.maskBoardEasy(this.matrix, mask);

			// save the solved matrix.
			this.save = this.matrix;

			// set the masked matrix as the puzzle.
			this.matrix = mask;

			timeDiff.start();
			this.done();
		}
		else
		{
			// the level is medium or greater. use the advanced mask
			// function to generate a minimal sudoku puzzle with a
			// single solution.
			this._doMask(this.matrix, mask);

			// if the level is medium, randomly add 4 extra hints.
			if(this.level == 1)
			{
				for(i = 0; i < 4; i++)
				{
					do
					{
						var cell = Math.floor(Math.random() * 81);
					}
					while(mask[cell] != 0);

					mask[cell] = this.matrix[cell];
				}
			}
		}
	}

	// this method solves the current game by restoring the solved matrix.
	// if the original unmodified masked matrix was saved, this function
	// could call the solve method which would undo any wrong player guesses
	// and actually solve the game.
	this.solveGame = function() {
		this.matrix = this.save;
	}

	// this method determines wether or not the game has been completed. it
	// looks at each cell and determines whether or not a value has been
	// entered. if not, the game is not done. if a value has been entered,
	// it calls checkVal() to make sure the value does not violate the
	// sudoku rules. if both checks are passed for each cell in the board
	// the game is complete.
	this.gameFinished = function()
	{
		for(var i = 0; i < 9; i++)
		{
			for(var j = 0; j < 9; j++)
			{
				var val = this.matrix[i * 9 + j];
				if((val == 0) || (this._checkVal(this.matrix, i, j, val) == false))
					return 0;
			}
		}

		return timeDiff.end();
	}
}

</script>
<script type="text/javascript">

// implementing trim because IE sucks my balls.
if(typeof String.prototype.trim !== 'function') {
	String.prototype.trim = function() {
		return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	}
}

// stores the puzzle instance
var thePuzzle;
var solvedPuzzle;
var firstGame = true;
var keepOverlayBackground = false;
var enableErrors = false;
var offset = 0;
var reset = false;
var isGameWon = false;
var hints;
var MAX_HINTS = 5;
var maxHints;
var menuTextMain = "Menu";
var menuTextClose = "Close";

// initialize a new game. this generates and loads a new puzzle and sets up the
// user interface controls.
function init() {
	thePuzzle = new Sudoku();

	// update the level radio buttons with the current puzzle level.
	for(var i = 0; i < document.controls.level.length; i++)
	{
		$("#difficulty" + i).bind("change", difficultyLevel);
		if(document.controls.level[i].value == thePuzzle.level)
		{
			document.controls.level[i].checked = true;
			$("#lblDifficulty" + i).addClass("selectedLabel");
		}
	}

	// initialize each cell.
	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			var cell = document.getElementById("x" + i + "_" + j);

			// install the onclick handler
			cell.onclick = selectCell;

			// when the page is first loaded, in firefox, first
			// child is an empty text node, in IE first child is
			// null.
			if(!cell.firstChild)
				cell.appendChild(document.createTextNode(""));

			// if the value is 0, create a blank cell.
			if(thePuzzle.getVal(i, j) == 0)
				cell.firstChild.nodeValue = "";
			else {
				// if the value is not 0, set the value and mark
				// the cell as a hint.
				cell.firstChild.nodeValue = thePuzzle.getVal(i, j);
				addClass(cell, "hint");
			}
		}
	}

	// install the keyboard handler
	if(document.all) {
		document.body.onkeydown = getKey;
	}
	else {
		document.documentElement.onkeydown = getKey;
	}
	
	$('#timer').runner();
	$('#timer').runner({
		milliseconds: false,
	});
	$('#timer').runner('start');
	
	newGame();
	if(firstGame)
		firstGame = false;
}

// start a new game. this resets the board and generates a new puzzle.
function newGame() {
	maxHints = MAX_HINTS;
	hints = [];
	solvedPuzzle = [];
	$("#hintIcon").removeClass("disable");
	unselectCell();
	$(".loadingScreen").show(); 
	loadInterval = window.setInterval("load()", 15);
	
	// update the puzzle difficulty level based on the radio buttons.
	for(var i = 0; i < document.controls.level.length; i++)
	{
		if(document.controls.level[i].checked == true)
			thePuzzle.level = document.controls.level[i].value;
	}
	
	keepOverlayBackground = true;
	isGameWon = false;
	if(!firstGame)
		toggleMenu(true, false);
	
	thePuzzle.done = function() {
		// update the board with the new puzzle data.
		for(var i = 0; i < 9; i++) {
			for(var j = 0; j < 9; j++) {
				var cell = $("#x" + i + "_" + j);
				cell.removeClass("error").removeClass("solved").removeClass("found").removeClass("choosenHint").removeClass("hint");
				if(thePuzzle.getVal(i, j) == 0) {
					cell.html("");
				}
				else {
					cell.html(thePuzzle.getVal(i, j));
					cell.addClass("hint");
				}
			}
		}
		
		window.clearInterval(loadInterval);
		$(".loadingScreen").hide();
		$("#loadIcon").removeAttr("style");
		offset = 0;
		$("#overlayBackground").addClass("hide");
		keepOverlayBackground = false;
		
		$("#resetCells").removeAttr("disabled");
		$("#enableErrors").removeAttr("disabled");
		$("#solveIt").removeAttr("disabled");
		$('#timer').runner('reset');
		
		thePuzzle.solveGame();
		setSolvedPuzzle();
		setHints();
	};

	// generate the new puzzle.
	thePuzzle.newGame();
}

// solve the game and display the solution.
function solve() {
	var counter = 0;

	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			var cell = $("#x" + i + "_" + j);
			cell.html(solvedPuzzle[counter++]);
			
			cell.removeClass("error").removeClass("found").removeClass("choosenHint").addClass("solved");
		}
	}
	
	keepOverlayBackground = true;
	toggleMenu(true, false);
	$("#resetCells").attr("disabled", "disabled");
	$("#enableErrors").attr("disabled", "disabled");
	$("#solveIt").attr("disabled", "disabled");
	$('#timer').runner('stop');
}

// stores the last cell clicked on by the user.
var selectedCell;

// selects the cell clicked on by the user.
function selectCell()
{
	unselectCell();

	// if the cell is one that was automatically populated just return and
	// not allow the cell to be selected.
	if(containsClass(this, "hint") || containsClass(this, "solved"))
		return;

	// save the selected cell and highlight the square on the board.
	selectedCell = this;
	addClass(selectedCell, "selected");
}

// move the selected cell up to the next user selectable cell. if no cells are
// selected this will automatically select the lowest right-most user selectable
// cell. if there are no more cells up in the current column the selection will
// wrap to the bottom and move one column to the left.
function moveUp()
{	
	var row;
	var col;
	if(!selectedCell)
	{
		row = 9;
		col = 8;
	}
	else
	{
		var id = selectedCell.id;
		id = id.substr(1);
		var arr = id.split("_");
		row = arr[0];
		col = arr[1];
	}

	unselectCell();
	
	var cell;
	do
	{
		row--;
		if(row < 0)
		{
			row = 8;
			col = (col + 8) % 9;
		}
		cell = document.getElementById("x" + row + "_" + col);
		if(containsClass(cell, "solved"))
			return;
	}
	while(containsClass(cell, "hint"));

	selectedCell = cell;
	addClass(selectedCell, "selected");
}

// move the selected cell down to the next user selectable cell. if no cells are
// selected this will automatically select the top left-most user selectable
// cell. if there are no more cells down in the current column the selection
// will wrap to the top and move one column to the right.
function moveDown()
{
	var row;
	var col;
	if(!selectedCell)
	{
		row = -1;
		col = 0;
	}
	else
	{
		var id = selectedCell.id;
		id = id.substr(1);
		var arr = id.split("_");
		row = arr[0];
		col = arr[1];
	}

	unselectCell();

	var cell;
	do
	{
		row++; 
		if(row > 8)
		{
			row = 0;
			col = (col + 1) % 9;
		}
		cell = document.getElementById("x" + row + "_" + col);
		if(containsClass(cell, "solved"))
			return;
	}
	while(containsClass(cell, "hint"));

	selectedCell = cell;
	addClass(selectedCell, "selected");
}

// move the selected cell left to the next user selectable cell. if no cells are
// selected this will automatically select the right-most bottom user selectable
// cell. if there are no more cells left in the current row the selection will
// wrap to the right and move one row up.
function moveLeft()
{
	var row;
	var col;
	if(!selectedCell)
	{
		row = 8;
		col = 9;
	}
	else
	{
		var id = selectedCell.id;
		id = id.substr(1);
		var arr = id.split("_");
		row = arr[0];
		col = arr[1];
	}

	unselectCell();

	var cell;
	do
	{
		col--;
		if(col < 0)
		{
			col = 8;
			row = (row + 8) % 9;
		}
		cell = document.getElementById("x" + row + "_" + col);
		if(containsClass(cell, "solved"))
			return;
	}
	while(containsClass(cell, "hint"));

	selectedCell = cell;
	addClass(selectedCell, "selected");
}

// move the selected cell right to the next user selectable cell. if no cells
// are selected this will automatically select the left-most top user
// selectable cell. if there are no more cells right in the current row the
// selection will wrap to the left and move one row down.
function moveRight()
{
	var row;
	var col;
	if(!selectedCell)
	{
		row = 0;
		col = -1;
	}
	else
	{
		var id = selectedCell.id;
		id = id.substr(1);
		var arr = id.split("_");
		row = arr[0];
		col = arr[1];
	}

	unselectCell();

	var cell;
	do
	{
		col++; 
		if(col > 8)
		{
			col = 0;
			row = (row + 1) % 9;
		}
		cell = document.getElementById("x" + row + "_" + col);
		if(containsClass(cell, "solved"))
			return;
	}
	while(containsClass(cell, "hint"));

	selectedCell = cell;
	addClass(selectedCell, "selected");
}

// unselects the selected cell. values entered are ignored until a cell is
// selected again.
function unselectCell()
{
	if(selectedCell)
		removeClass(selectedCell, "selected");
	selectedCell = null;
}

// sets the value for the selected cell.
function setVal(row, col, val)
{
	// if there is no cell selected, ignore the input value.
	if(!selectedCell && !reset)
		return;

	// set the puzzle value and draw the value in the cell.
	thePuzzle.setVal(1 * row, 1 * col, val);
	$("#x" + row + "_" + col).html((val > 0) ? val : "");
	
	// check for conflicting values according to the sudoku rules and mark
	// them.
	if(enableErrors)
		showErrors(1 * row, 1 * col);
		
	for(i = 0; i < hints.length; i++)
	{
		if(hints[i][0] == row && hints[i][1] == col && hints[i][2] == solvedPuzzle[(row * 1) * 9 + (col * 1)])
		{
			hints.splice(i, 1);
			if(hints.length < maxHints)
				maxHints--;
			$("#availableHints").html(maxHints);
		}
	}
	
	// check to see if the game is done.
	isGameOver();
}

// adds a css class to an html element.
function addClass(el, name)
{
	var arr;
	var classes = el.className;
	if(!classes)
		arr = new Array();
	else {
		classes = classes.trim();
		arr = classes.split(" ");
	}

	if(!arr.contains(name))
		arr.push(name);

	el.className = arr.join(" ");
}

// removes a css class from an html element.
function removeClass(el, name)
{
	var arr;
	var classes = el.className;
	if(classes)
		arr = classes.split(" ");
	else
		arr = new Array();

	var arr2 = new Array();

	for(var i = 0; i < arr.length; i++)
	{
		if(arr[i] != name)
			arr2.push(arr[i]);
	}

	if(arr2.length > 0)
		el.className = arr2.join(" ");
	else
		el.className = "";
}

// determines whether or not an html element has the given class.
function containsClass(el, name)
{
	var classes = el.className;
	var arr;
	if(classes)
		arr = classes.split(" ");
	else
		arr = new Array();

	return arr.contains(name);
}

// checks the row, column and subsquare for the given row and column for any
// conflicting values and highlights them. if there were any previously
// highlighted that are no longer conflicting, the highlighting is removed.
function showErrors(row, col)
{
	var counter = 0;
	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			var cell = $("#x" + i + "_" + j);
			var val = thePuzzle.getVal(i, j);
			
			if(thePuzzle.checkVal(i, j, val))
				cell.removeClass("error");
			else
				cell.addClass("error");
				
			if(!(cell.hasClass("hint")))
			{
				if(solvedPuzzle[counter] != cell.html())
					cell.removeClass("found");
				else
					cell.addClass("found");
			}
			counter++;
		}
	}
}

// gets the keyboard input.
function getKey(e)
{
	var id;
	var arr;
	if(selectedCell)
	{
		id = selectedCell.id;
		id = id.substr(1);
		arr = id.split("_");
	}

	if(document.all)
		e = event;

	if(e.keyCode)
		code = e.keyCode;
	else if(e.which)
		code = e.which;

	switch(code)
	{
	case 37: // lt
		moveLeft();
		break;
	case 38: // up
		moveUp();
		break;
	case 39: // rt
		moveRight();
		break;
	case 40: // dn
		moveDown();
		break;
	case 8: // backspace
	case 46: // delete
		if(arr)
			setVal(arr[0], arr[1], 0);
		return false;
		break;
	case 27: // escape
		unselectCell();
		break;
	default:
		if(arr)
		{
			if(code >= 49 && code <= 57) {				
				setVal(arr[0], arr[1], code - 48);	
			}		
			else if(code >= 97 && code <= 105) {
				setVal(arr[0], arr[1], code - 96);
			}
		}
		break;
	}
}	

function difficultyLevel()
{
	for(var i = 0; i < 4; i++)
	{
		if($(this).val() == i)
			$("#lblDifficulty" + i).addClass("selectedLabel");
		else
			$("#lblDifficulty" + i).removeClass("selectedLabel");
	}
	
}

function toggleErrors()
{
	enableErrors = !enableErrors;
	
	if(enableErrors)
	{
		$("#enableErrors").addClass("selectedLabel");
		for (var i = 0; i < 9; i++)
		{
			for (var j = 0; j < 9; j++)
			{
				var cell = $("#x" + i + "_" + j);
				var val = thePuzzle.getVal(i, j);
				if(thePuzzle.checkVal(i, j, val) == true)
				{
					if(val == cell.html() && !cell.hasClass("hint"))
						cell.addClass("found");
					cell.removeClass("error");
				}
				else
				{
					cell.addClass("error");
					cell.removeClass("found");
				}
			}
		}
	}
	else
	{
		$("#enableErrors").removeClass("selectedLabel");
		for (var i = 0; i < 9; i++)
		{
			for (var j = 0; j < 9; j++)
			{
				removeClass(document.getElementById("x" + i + "_" + j), "error");
				removeClass(document.getElementById("x" + i + "_" + j), "found");
			}
		}
	}
		
	toggleMenu(true, false);
}

function toggleMenu(settings, gameWon)
{
	$('#timer').runner('stop');
	$("#gameEnded").hide();
	if(!isGameWon)
		$("#overlayIcons").addClass("hide");
	
	$("#overlayBackground").removeClass("hide");
	unselectCell();
	
	if(settings)
	{	
		if($("#settings").hasClass("hide")) // Show
		{
			$("#settings").removeClass("hide");
			$("#menuText").html(menuTextClose);
			$("#menuIcon").removeClass("fa-cog").addClass("fa-close");
			$("#menuItem").addClass("orange");
			
			// update the puzzle difficulty level based on the radio buttons.
			for(var i = 0; i < document.controls.level.length; i++)
			{
				if(thePuzzle.level == document.controls.level[i].value)
					$("#lblDifficulty" + i).trigger("click");
			}
		}
		else // Hide
		{
			if(!keepOverlayBackground)
				$("#overlayBackground").addClass("hide");
			$("#settings").addClass("hide");
			$('#timer').runner('start');
			$("#menuText").html(menuTextMain);
			$("#menuIcon").addClass("fa-cog").removeClass("fa-close");
			$("#menuItem").removeClass("orange");
		}
	}
	
	if(gameWon)
	{
		$('#timer').runner('stop');
		$("#gameEnded").show();
		isGameWon = true;
		$("#overlayIcons").removeClass("hide");
	}
}

function load()
{
	offset += 10;
	$('#loadIcon').css({
		'-moz-transform': 'rotate(' + offset + 'deg)',
		'-webkit-transform': 'rotate(' + offset + 'deg)',
		'-o-transform': 'rotate(' + offset + 'deg)',
		'-ms-transform': 'rotate(' + offset + 'deg)',
		'transform': 'rotate(' + offset + 'deg)',
	});
}

function resetSudokuCells()
{
	reset = true;
	unselectCell();
	var counter = 0;
	
	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			var cell = $("#x" + i + "_" + j);
			
			if(cell.hasClass("hint") && cell.hasClass("choosenHint"))
				cell.removeClass("hint");
			
			if(!(cell.hasClass("hint")))
			{
				setVal(i, j, solvedPuzzle[counter]);
				cell.html("");
			}
			
			cell.removeClass("error").removeClass("found").removeClass("choosenHint");
			counter++;
		}
	}
	
	setHints();
	reset = false;
	maxHints = MAX_HINTS;
	$("#availableHints").html(maxHints);
	$("#hintIcon").removeClass("disable")
	$('#timer').runner('reset');
	toggleMenu(true, false);
}

function isGameOver()
{
	var invalidCells = 0;
	var counter = 0;
	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			var val = $("#x" + i + "_" + j).html() == "" ? 0 : $("#x" + i + "_" + j).html();
			
			if(solvedPuzzle[counter++] != val) {
				invalidCells++;
			}
		}
	}
	
	// Game is over
	if(invalidCells == 0)
	{
		$("#resetCells").attr("disabled", "disabled");
		$("#enableErrors").attr("disabled", "disabled");
		$("#solveIt").attr("disabled", "disabled");
		toggleMenu(false, true);
	}
}

function setHints()
{
	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			if(!$("#x" + i + "_" + j).hasClass("hint")) {
				pushArray = [i, j, thePuzzle.getVal(i, j)];
				hints.push(pushArray);
			}
		}
	}
	$("#availableHints").html(maxHints);
}

function setSolvedPuzzle()
{
	for(var i = 0; i < 9; i++) {
		for(var j = 0; j < 9; j++) {
			solvedPuzzle.push(thePuzzle.getVal(i, j));
		}
	}
}

function showRandomHint()
{
	var currentHints= maxHints;
	if(maxHints != 0)
	{
		var randIndex = Math.floor((Math.random() * hints.length));
		
		$("#x" + hints[randIndex][0] + "_" + hints[randIndex][1]).addClass("hint").addClass("choosenHint").html(hints[randIndex][2]);
		setVal(hints[randIndex][0], hints[randIndex][1], hints[randIndex][2]);
		
		if(!enableErrors)
			hints.splice(hints.indexOf(hints[randIndex]), 1);
		
		if(maxHints == currentHints)
			maxHints--;
		if(maxHints == 0)
		{
			$("#hintIcon").addClass("disable");
		}
		$("#availableHints").html(maxHints);
	}
}

window.addEventListener("keydown", function(e) {
    // space and arrow keys
    if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
        e.preventDefault();
    }
}, false);

</script>
	</head>
	<body>
		<table id="outer" class="outer sudokuContainer">
			<tr>
				<td colspan="3" class="sudokuTop" style="text-align:right;">
					<div class="menuItem" onclick="window.print();">
						<i class="icon fa fa-print"></i>
						Print
					</div>
					<div class="menuItem" onclick="showRandomHint();">
						<sup id="availableHints"></sup>
						<i id="hintIcon" class="icon fa fa-exclamation"></i>
						Hint
					</div>
					<div id="menuItem" class="menuItem" onclick="toggleMenu(true, false);">
						<i id="menuIcon" class="icon fa fa-cog"></i>
						<span id="menuText">Menu</span>
					</div>
					
					<!-- Menus -->
					<section id="settings" class="hide">
						<form name="controls" class="controls">
							<input id="difficulty0" type="radio" name="level" value="0" class="hide" /><label id="lblDifficulty0" for="difficulty0">Easy</label>
							<input id="difficulty1" type="radio" name="level" value="1" class="hide" /><label id="lblDifficulty1" for="difficulty1">Medium</label>
							<input id="difficulty2" type="radio" name="level" value="2" class="hide" /><label id="lblDifficulty2" for="difficulty2">Hard</label>
							<input id="difficulty3" type="radio" name="level" value="3" class="hide" /><label id="lblDifficulty3" for="difficulty3">Expert</label>							
							<br/>
							<input id="new" type="button" value="New Game" onclick="newGame();" />
							<input id="solveIt" type="button" value="Solve It" onclick="solve();" />
							<input id="resetCells" type="button" value="Reset Board" onclick="resetSudokuCells();" />
							<input id="enableErrors" type="button" value="Show Errors" class="" onclick="toggleErrors();" />
						</form>
					</section>
					<section id="gameEnded" class="hide">
						<div class="controls" style="font-size:40px;">
							<i style="color:gold" class="fa fa-trophy"></i>
							Congratulations!
							<i style="color:gold" class="fa fa-trophy"></i>
							<br />
							<strong>Time:</strong><span id="timer"></span>
							<input id="continue" type="button" value="Continue" onclick="toggleMenu(true, false);" />
						</div>
					</section>
					<section id="overlayBackground" class="hide"></section>
					<section id="overlayIcons" class="hide"></section>
					<section class="loadingScreen"><i id="loadIcon" class="fa fa-spinner"></i></section>
				</td>
			</tr>
			<tr>
				<td>
					<table class="inner">
						<tr>
							<td id="x0_0">
							</td>
							<td id="x0_1">
							</td>
							<td id="x0_2">
							</td>
						</tr>
						<tr>
							<td id="x1_0">
							</td>
							<td id="x1_1">
							</td>
							<td id="x1_2">
							</td>
						</tr>
						<tr>
							<td id="x2_0">
							</td>
							<td id="x2_1">
							</td>
							<td id="x2_2">
							</td>
						</tr>
					</table>
				</td>
				<td>
					<table class="inner">
						<tr>
							<td id="x0_3">
							</td>
							<td id="x0_4">
							</td>
							<td id="x0_5">
							</td>
						</tr>
						<tr>
							<td id="x1_3">
							</td>
							<td id="x1_4">
							</td>
							<td id="x1_5">
							</td>
						</tr>
						<tr>
							<td id="x2_3">
							</td>
							<td id="x2_4">
							</td>
							<td id="x2_5">
							</td>
						</tr>
					</table>
				</td>
				<td>
					<table class="inner">
						<tr>
							<td id="x0_6">
							</td>
							<td id="x0_7">
							</td>
							<td id="x0_8">
							</td>
						</tr>
						<tr>
							<td id="x1_6">
							</td>
							<td id="x1_7">
							</td>
							<td id="x1_8">
							</td>
						</tr>
						<tr>
							<td id="x2_6">
							</td>
							<td id="x2_7">
							</td>
							<td id="x2_8">
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<table class="inner">
						<tr>
							<td id="x3_0">
							</td>
							<td id="x3_1">
							</td>
							<td id="x3_2">
							</td>
						</tr>
						<tr>
							<td id="x4_0">
							</td>
							<td id="x4_1">
							</td>
							<td id="x4_2">
							</td>
						</tr>
						<tr>
							<td id="x5_0">
							</td>
							<td id="x5_1">
							</td>
							<td id="x5_2">
							</td>
						</tr>
					</table>
				</td>
				<td>
					<table class="inner">
						<tr>
							<td id="x3_3">
							</td>
							<td id="x3_4">
							</td>
							<td id="x3_5">
							</td>
						</tr>
						<tr>
							<td id="x4_3">
							</td>
							<td id="x4_4">
							</td>
							<td id="x4_5">
							</td>
						</tr>
						<tr>
							<td id="x5_3">
							</td>
							<td id="x5_4">
							</td>
							<td id="x5_5">
							</td>
						</tr>
					</table>
				</td>
				<td>
					<table class="inner">
						<tr>
							<td id="x3_6">
							</td>
							<td id="x3_7">
							</td>
							<td id="x3_8">
							</td>
						</tr>
						<tr>
							<td id="x4_6">
							</td>
							<td id="x4_7">
							</td>
							<td id="x4_8">
							</td>
						</tr>
						<tr>
							<td id="x5_6">
							</td>
							<td id="x5_7">
							</td>
							<td id="x5_8">
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<table class="inner">
						<tr>
							<td id="x6_0">
							</td>
							<td id="x6_1">
							</td>
							<td id="x6_2">
							</td>
						</tr>
						<tr>
							<td id="x7_0">
							</td>
							<td id="x7_1">
							</td>
							<td id="x7_2">
							</td>
						</tr>
						<tr>
							<td id="x8_0">
							</td>
							<td id="x8_1">
							</td>
							<td id="x8_2">
							</td>
						</tr>
					</table>
				</td>
				<td>
					<table class="inner">
						<tr>
							<td id="x6_3">
							</td>
							<td id="x6_4">
							</td>
							<td id="x6_5">
							</td>
						</tr>
						<tr>
							<td id="x7_3">
							</td>
							<td id="x7_4">
							</td>
							<td id="x7_5">
							</td>
						</tr>
						<tr>
							<td id="x8_3">
							</td>
							<td id="x8_4">
							</td>
							<td id="x8_5">
							</td>
						</tr>
					</table>
				</td>
				<td>
					<table class="inner">
						<tr>
							<td id="x6_6">
							</td>
							<td id="x6_7">
							</td>
							<td id="x6_8">
							</td>
						</tr>
						<tr>
							<td id="x7_6">
							</td>
							<td id="x7_7">
							</td>
							<td id="x7_8">
							</td>
						</tr>
						<tr>
							<td id="x8_6">
							</td>
							<td id="x8_7">
							</td>
							<td id="x8_8">
							</td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<script>init();</script>
	</body>
</html>

